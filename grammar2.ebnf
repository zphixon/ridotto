(* each rule may be separated by whitespace *)

typeDecl = 'type', uppercaseIdent, [typeDeclArgs], typeDescription | typeAlias;
typeDeclArgs = '[',
    [ lowercaseIdent, { ',', lowercaseIdent } ],
    { lowercaseIdent, typeAlias, { ',', lowercaseIdent, typeAlias } },
']';
typeAlias = '=', typeSpec;

typeSpec = uppercaseIdent, [typeSpecArgs];
typeSpecArgs = '[',
    lowercaseIdent, [typeAlias],
    { ',', lowercaseIdent, [typeAlias] }, [',']
']';

typeDescription =
    whereClause | doesClause | isClause | hasClause,
    { whereClause | doesClause | isClause | hasClause };

whereClause = 'where', '{', {lowercaseIdent, typeAlias}, '}';
doesClause = 'does', '{', {functionHead | function}, '}';
isClause = 'is', '{', {enumVariant}, '}';
hasClause = 'has', '{', {varType}, '}';

functionHead = functionModifiers, 'fn', lowercaseIdent, [typeDeclArgs], '(',
    lowercaseIdent, ':', typeSpec,
    { ',', lowercaseIdent, ':', typeSpec }, [','],
')', ['->', typeSpec];
function = functionHead, '{', { statement }, '}';
functionModifiers = 'async' | 'builtin' | 'export' | 'const';

enumVariant = lowercaseIdent, ['{', {varType}, '}'];

statement = 'stmt';

varType = lowercaseIdent, typeSpec;

lowercaseIdent = 'lower';
uppercaseIdent = 'Upper';